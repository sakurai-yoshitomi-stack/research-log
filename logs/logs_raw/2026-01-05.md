# 📅 2026-01-05
## 対話ログ（生ログ寄り）

---

### [10:42] アシスタント
[空]

---

### [10:42] アシスタント
はい、**PDFはバックエンドサーバーで生成されます**。  
しかも、**実務では「バックエンドで作る」のが標準・推奨**です。

---

## 結論（まず一言）

👉 **PDFは FastAPI（Python）側で生成する**  
👉 フロント（React）は **「要求する・受け取って保存するだけ」**

---

## なぜバックエンドでPDFを作るのか

### ① セキュリティ上の理由
- 帳票データは **DBの業務データ**
- フロントでPDF生成すると
  - 生データをブラウザに全部渡す必要がある
  - 改ざん・漏えいリスクが高い

👉 **DBに近いバックエンドで完結させるのが安全**

---

### ② 業務ロジックがバックエンドにある

- 集計
- 金額計算
- 日付フォーマット
- 帳票レイアウト制御

これらはすでに **Python側にロジックがある**ため、

👉 **PDF生成も同じ層でやるのが自然**

---

### ③ 品質・再現性が安定する

- フロント生成（jsPDFなど）
  - ブラウザ差異
  - フォント問題
  - レイアウト崩れ

- バックエンド生成
  - サーバー固定環境
  - 帳票レイアウトが安定
  - 印刷品質が高い

---

## 正しい責務分離（超重要）

| 役割 | 担当 |
|---|---|
| PDF作成 | ✅ バックエンド（FastAPI） |
| 帳票データ取得 | ✅ バックエンド |
| レイアウト定義 | ✅ バックエンド |
| ダウンロード要求 | フロント（React） |
| Blob化・保存 | フロント（React） |

---

## 実際のPDF生成位置（サーバー内）

```
FastAPI
 ├─ APIエンドポイント
 ├─ 業務ロジック
 ├─ PDF生成処理 ← ★ここ
 │    ├─ HTMLテンプレート
 │    └─ PDF変換
 └─ PDFレスポンス返却
```

PDFは以下のどちらかで生成されます：

- **メモリ上（bytes）** ← よく使う
- **一時ファイル**（/tmpなど）

※ 最終的に **ファイル保存は不要**  
→ そのままレスポンスで返すのが一般的

---

## よく使われるPython PDF生成手段

| 方法 | 用途 |
|---|---|
| reportlab | 帳票・罫線・固定レイアウト |
| WeasyPrint | HTML＋CSSで帳票 |
| wkhtmltopdf | HTML→PDF（実務多い） |

---

## フロントでPDFを作るのはダメ？

❌ **帳票・業務PDFでは非推奨**  
⭕ **例外的にOKなケース**
- 画面キャプチャ的PDF
- 簡易レポート
- 個人利用ツール

---

## 設計書にそのまま書ける表現

> PDF帳票は、業務データの安全性および帳票品質を確保するため、バックエンドサーバー（FastAPI）にて生成し、フロントエンドはPDF生成要求およびダウンロード処理のみを担う。

---

次に進むなら👇  
- 📌 **「PDFをメモリ生成 vs 一時ファイル生成」設計比較**
- 📌 **帳票系PDFの標準ディレクトリ構成**
- 📌 **FastAPI PDF生成の実装サンプル**

どれいきますか？

---

### [10:42] ユーザー
pdfは、バックエンドサーバーにつくれられるの？

---

### [10:43] アシスタント
いい質問です。  
ここは **設計レビューで必ず聞かれるポイント**なので、  
**仕組み → 実装イメージ → 設計書用表現**の順で整理します。

---

# 結論（まず一言）

👉 **バックエンドで生成したPDFは、HTTPレスポンスとしてフロントへ返す**  
👉 **フロントは「ファイルを受信して保存」するだけ**

**ファイルサーバ経由でもURLでもありません（同期版）**

---

## ① 基本原理（どうやって持ってくる？）

PDFはこうしてフロントに届きます👇

```
FastAPI
  ├ PDFを生成（bytes）
  └ HTTPレスポンスにPDFを詰める
        ↓
React
  └ バイナリ（Blob）として受信
        ↓
ブラウザが保存
```

つまり

> **PDF = APIレスポンスの中身**

---

## ② バックエンド側（FastAPI）のやり方

### 重要なポイント（これが全て）

- `Content-Type: application/pdf`
- `Content-Disposition: attachment`

### 概念コード（イメージ）

```python
from fastapi import Response

@app.post("/api/pdf/download")
async def download_pdf():
    pdf_bytes = create_pdf()  # ← ここでPDF生成

    return Response(
        content=pdf_bytes,
        media_type="application/pdf",
        headers={
            "Content-Disposition": "attachment; filename=report.pdf"
        }
    )
```

✔ ファイル保存しなくていい  
✔ メモリ上で完結  
✔ 即フロントへ送信

---

## ③ フロント側（React）のやり方

### ポイント

- `responseType: 'blob'`
- Blob → ダウンロードリンク化

### 処理イメージ

```
APIレスポンス（PDFバイナリ）
   ↓
Blobオブジェクト生成
   ↓
一時URL生成（URL.createObjectURL）
   ↓
aタグ click()
```

### 概念コード

```ts
axios.post('/api/pdf/download', data, {
  responseType: 'blob',
}).then(res => {
  const blob = new Blob([res.data], { type: 'application/pdf' })
  const url = URL.createObjectURL(blob)

  const a = document.createElement('a')
  a.href = url
  a.download = 'report.pdf'
  a.click()

  URL.revokeObjectURL(url)
})
```

---

## ④ なぜ「URLで取りに行かない」の？

### よくある誤解

❌ `/pdf/report.pdf` を直接叩く  
❌ S3のURLを返す（同期帳票）

### 問題点

- 認可制御が難しい
- URL漏えいリスク
- 帳票生成とダウンロードが分離する

👉 **業務帳票はAPIレスポンスで返すのが正解**

---

## ⑤ 処理フロー（文章化）

1. フロントエンドからPDF生成要求APIを呼び出す  
2. バックエンドで業務データを取得しPDFを生成する  
3. 生成したPDFをHTTPレスポンス（application/pdf）として返却する  
4. フロントエンドはレスポンスをBlobとして受信し、ダウンロード処理を行う  

---

## ⑥ 非同期方式との違い（参考）

| 項目 | 同期 | 非同期 |
|---|---|---|
| 受け渡し | HTTPレスポンス | ダウンロードAPI |
| PDF保存 | 不要 | 必要 |
| 処理時間 | 短い | 長い帳票向け |

※ 今回は **同期方式**なのでレスポンス返却が正解

---

## 設計書にそのまま使える表現

> バックエンドで生成したPDFは、HTTPレスポンスのボディとして返却し、フロントエンドではBlobとして受信することで、ユーザー端末へダウンロードさせる。

---

ここまで理解できていれば **設計者レベルは十分クリア**です。  
次はどうします？

- 📌 **ストリーミング返却（大きいPDF対応）**
- 📌 **エラー時の扱い（PDF生成失敗）**
- 📌 **帳票APIのURL設計標準**

どれ行きますか？

---

### [10:43] ユーザー
バックエンドのPDFは、フロントへどうやってもってくるの？

---

### [10:48] アシスタント
[空]

---

### [10:48] アシスタント
IT統制（特に **IT全般統制：ITGC**）で求められるログは、「**不正・誤操作・障害を検知し、事後追跡できること**」が目的です。  
実務・監査（J-SOX／内部監査）で整理しやすい形でまとめます。

---

## ① アクセス・認証系ログ（最重要）

**目的**  
不正アクセス、なりすまし、権限逸脱の検知

**主なログ**
- ログイン／ログアウト
- ログイン失敗（回数・IP・端末）
- パスワード変更
- 多要素認証（MFA）結果
- アカウントロック／解除

**例**
- OS認証ログ（Windows Event Log / Linux auth.log）
- AD / LDAP 認証ログ
- クラウド（Azure AD / AWS IAM）

---

## ② 権限・アカウント管理ログ

**目的**  
権限付与・変更・削除が正当かを証跡として残す

**主なログ**
- ユーザー作成／削除
- 権限付与／変更／剥奪
- 管理者権限の付与
- ロール変更

**監査でのポイント**
- 「**申請・承認とログが一致しているか**」
- 退職者・異動者の権限が即時削除されているか

---

## ③ 操作ログ（業務操作ログ）

**目的**  
「誰が・いつ・何をしたか」を追跡可能にする

**主なログ**
- 画面操作履歴（登録／更新／削除）
- 業務データの変更前後
- 重要マスタの変更
- 承認・差戻し操作

**重要項目**
- ユーザーID
- 処理日時
- 対象データID
- 処理内容（Before / After）

---

## ④ データ変更・監査ログ（アプリ監査ログ）

**目的**  
財務データ・重要情報の改ざん防止／検知

**主なログ**
- 会計データ変更履歴
- マスタデータ（取引先、単価等）
- 設定値変更
- 直接DB更新の履歴

**J-SOXで特に重要**
- **直接DB操作が禁止されているか**
- 許可されている場合、**ログが必ず残るか**

---

## ⑤ システム・エラーログ

**目的**  
障害・異常検知、業務停止リスク管理

**主なログ**
- アプリ例外（Exception）
- バッチ異常終了
- タイムアウト
- 外部IF接続エラー

**監査観点**
- エラー発生時に誰が対応したか
- 再発防止策が残っているか

---

## ⑥ ジョブ・バッチ処理ログ

**目的**  
定期処理・会計処理の完全性担保

**主なログ**
- バッチ開始／終了
- 正常終了／異常終了
- 件数チェック
- 再実行履歴

**例**
- 月次締め処理
- 売上計上バッチ
- 会計連携バッチ

---

## ⑦ インフラ・OS・ミドルウェアログ

**目的**  
基盤レベルの不正・障害検知

**主なログ**
- OS操作ログ（root / admin）
- サーバ起動／停止
- ファイルアクセス
- DB接続ログ
- SQL実行ログ（特権）

---

## ⑧ 設定変更・構成変更ログ（変更管理）

**目的**  
無断変更・設定ミスの防止

**主なログ**
- システム設定変更
- 環境変数変更
- FW / セキュリティ設定変更
- リリース・デプロイ履歴

---

## ⑨ 外部連携・IFログ

**目的**  
データ欠損・重複・不整合の検知

**主なログ**
- 送信／受信日時
- 連携件数
- 成功／失敗
- 再送履歴

---

## ⑩ ログ管理・保全ログ（ログそのものの統制）

**目的**  
ログ改ざん防止・証跡性確保

**主な統制**
- ログの保存期間（例：7年）
- ログ削除／ローテーション履歴
- アクセス制御（閲覧権限）
- 集約（SIEM等）

---

## IT統制ログの整理（監査向け一覧）

| 区分 | 例 | ITGC観点 |
|---|---|---|
| 認証 | ログイン | 不正アクセス |
| 権限 | 権限変更 | 職務分掌 |
| 操作 | 更新・削除 | 責任追跡 |
| データ | マスタ変更 | 改ざん防止 |
| 障害 | エラー | 業務継続 |
| バッチ | 処理結果 | 完全性 |
| OS | 管理者操作 | 基盤統制 |
| 変更 | 設定変更 | 変更管理 |
| IF | 連携ログ | 整合性 |
| 保全 | 保存・改ざん | 証跡性 |

---

## 実務でよくある指摘ポイント（重要⚠️）

- ログは **「出ている」だけではNG**
- **誰が、どの頻度で、どう確認しているか** が必須
- ログ確認結果の**記録（チェックログ）**がないと統制不十分
- 管理者自身の操作を**第三者が監視**しているか

---

必要であれば次に👇もできます  
- ✔ J-SOX監査での「指摘されないログ設計」
- ✔ Python / FastAPI / Reactでのログ分類設計
- ✔ ログ定義書・運用手順書テンプレート
- ✔ ログを絵（構成図・フロー図）で整理

どこまでのレベルで使いますか？（監査提出／設計標準／教育用 など）

---

### [10:48] ユーザー
IT統制におけるログの種類

---

### [10:49] アシスタント
{"prompt":"IT統制（ITGC）におけるログ管理を整理した日本語の構成図・フロー図。左から「利用者」「フロントエンド（React）」「バックエンド（FastAPI）」「DBサーバ（PostgreSQL）」「インフラ（OS/ミドルウェア）」を配置。各層から中央の「ログ管理基盤（SIEM／ログサーバ）」へ矢印。ログ種別として：認証ログ、権限変更ログ、操作ログ、データ変更ログ、エラーログ、バッチログ、OS操作ログ、設定変更ログ、IF連携ログ。右側に「ログ確認・監査」ボックス（定期レビュー、証跡保管、改ざん防止）。監査向けでシンプル、四角形と矢印、白背景、青とグレー基調、PPTに貼れる品質。","size":"1024x768","n":1}

---

### [10:50] ユーザー
ログを絵（構成図・フロー図）で整理

---

### [10:51] アシスタント
了解です。  
**「Python（FastAPI）／React 構成を前提に、IT統制（ITGC・J-SOX対応）でそのまま使えるログ分類設計」**を  
**設計書レベル**で整理します。

---

# 1️⃣ 全体構成（ログの流れ）

```
[ Browser / React ]
        │
        │ ① フロント操作ログ
        ▼
[ FastAPI ]
  ├─ ② 認証・認可ログ
  ├─ ③ 業務操作ログ
  ├─ ④ エラーログ
  ├─ ⑤ 監査ログ
        │
        ▼
[ Log Storage / SIEM / DB ]
        │
        ▼
[ 監査・運用確認 ]
```

👉 **原則**  
- **監査対象ログは必ずバックエンドで確定**
- Reactログは「補助証跡」

---

# 2️⃣ ログ分類一覧（統制対応マッピング）

| No | ログ種別 | 主担当 | 統制区分 |
|---|---|---|---|
| L1 | フロント操作ログ | React | 補助 |
| L2 | 認証・アクセスログ | FastAPI | ITGC |
| L3 | 権限管理ログ | FastAPI | ITGC |
| L4 | 業務操作ログ | FastAPI | ITAC |
| L5 | データ変更（監査）ログ | FastAPI/DB | J-SOX |
| L6 | エラー・例外ログ | FastAPI | ITGC |
| L7 | バッチ・ジョブログ | FastAPI | ITAC |
| L8 | インフラ・DBログ | OS/DB | ITGC |
| L9 | ログ保全・閲覧ログ | 共通 | ITGC |

---

# 3️⃣ React 側ログ設計（補助ログ）

## 目的
- UI操作の再現
- 障害時の一次調査

## 出力対象

| 種別 | 内容 |
|---|---|
| 画面遷移 | 画面ID → 画面ID |
| 操作 | ボタン押下 / 検索 |
| 入力 | バリデーションエラー |
| API呼び出し | 成功／失敗 |

## React ログ項目

```json
{
  "log_type": "FRONT_OPERATION",
  "user_id": "U001",
  "screen_id": "ORDER_001",
  "action": "CLICK_SUBMIT",
  "timestamp": "2026-01-05T10:20:00",
  "trace_id": "abc-123"
}
```

⚠️ **NG**
- 個人情報
- 金額・機密データ

---

# 4️⃣ FastAPI 側ログ設計（統制の中核）

## ① 認証・アクセスログ（L2）

```json
{
  "log_type": "AUTH",
  "user_id": "U001",
  "result": "SUCCESS",
  "ip": "192.168.0.1",
  "user_agent": "Chrome",
  "timestamp": "2026-01-05T10:20:01"
}
```

**統制ポイント**
- 失敗も必須
- IP・端末は監査で必ず見る

---

## ② 権限管理ログ（L3）

```json
{
  "log_type": "AUTHZ",
  "operator_id": "ADMIN01",
  "target_user": "U002",
  "before_role": "USER",
  "after_role": "ADMIN",
  "timestamp": "2026-01-05T10:30:00"
}
```

👉 **職務分掌の証跡**

---

## ③ 業務操作ログ（L4）

```json
{
  "log_type": "BUSINESS",
  "user_id": "U001",
  "action": "UPDATE_ORDER",
  "target_id": "ORD-999",
  "timestamp": "2026-01-05T10:35:00"
}
```

---

## ④ データ変更・監査ログ（L5）【最重要】

```json
{
  "log_type": "AUDIT",
  "table": "orders",
  "pk": "ORD-999",
  "before": { "amount": 10000 },
  "after": { "amount": 12000 },
  "changed_by": "U001",
  "timestamp": "2026-01-05T10:35:01"
}
```

✅ **J-SOX必須**
- Before / After
- 誰が

---

## ⑤ エラーログ（L6）

```json
{
  "log_type": "ERROR",
  "level": "ERROR",
  "message": "DB connection failed",
  "trace_id": "abc-123",
  "timestamp": "2026-01-05T10:36:00"
}
```

---

# 5️⃣ TraceID 設計（フロント⇔バック統合）

```
React
  ↓ trace_id
FastAPI
  ↓ trace_id
DB / Log
```

**効果**
- 監査・障害調査が一瞬

---

# 6️⃣ ログレベル定義（統制用）

| Level | 使用例 |
|---|---|
| INFO | 正常操作 |
| WARNING | 不正兆候 |
| ERROR | 障害 |
| CRITICAL | セキュリティ |

---

# 7️⃣ 保存・保全ルール（監査必須）

| 項目 | 内容 |
|---|---|
| 保存期間 | 5～7年 |
| 改ざん防止 | WORM / 権限分離 |
| 閲覧権限 | 監査のみ |
| ログ削除 | 禁止 |

---

# 8️⃣ 監査で「強い」設計チェックリスト

- ☑ フロントログに頼っていない  
- ☑ 監査ログは DB/サーバ側  
- ☑ 管理者操作が残る  
- ☑ TraceIDで一貫追跡  
- ☑ ログ確認の運用がある  

---

## 次にできること
- 📘 **ログ定義書テンプレ（Excel/Word）**
- 🧩 **FastAPI logging / structlog 実装例**
- 🎨 **構成図・フロー図（PPT貼付可）**
- 📝 **J-SOX向け運用手順書**

👉 次は「**設計書に貼る1枚構成図**」にしますか？  
それとも **「実装コード標準」** に落としますか？

---

### [10:51] ユーザー
Python / FastAPI / Reactでのログ分類設計

---

### [12:49] アシスタント
[空]

---

### [12:49] アシスタント
了解です 👍  
たぶんご要望は **「Python コーディ

---

### [12:49] ユーザー
Python コーディング規約　ワークワイルとかの銘永輝訳

---

### [12:50] アシスタント
了解です。  
**Python コーディング規約における「命名規約（ネーミングルール）」**を、**PEP8（公式規約）ベース＋実務向け補足**で整理します。

---

## 1. 基本原則（超重要）

- **意味が分かる名前を付ける**
- **省略しすぎない**
- **一貫性を最優先**
- **スコープが広いほど名前は明確に**

❌ `data`, `tmp`, `val`  
⭕ `user_profile`, `order_total_amount`

---

## 2. 命名規約一覧（早見表）

| 種類 | 命名形式 | 例 |
|---|---|---|
| **変数** | `snake_case` | `user_name`, `total_price` |
| **関数** | `snake_case` | `get_user()`, `calculate_total()` |
| **クラス** | `PascalCase` | `UserService`, `OrderRepository` |
| **定数** | `UPPER_SNAKE_CASE` | `MAX_RETRY_COUNT` |
| **モジュール** | `snake_case` | `user_service.py` |
| **パッケージ** | `snake_case` | `auth`, `payment_gateway` |
| **例外クラス** | `PascalCase + Error` | `ValidationError` |
| **プライベート** | `_prefix` | `_internal_func` |
| **マジック** | `__name__` | `__init__`, `__str__` |

---

## 3. 変数名の命名規約

### ✅ 推奨
```python
user_id = 10
order_count = 5
is_active = True
has_permission = False
```

### ❌ 非推奨
```python
u = 10
cnt = 5
flag = True
```

### 真偽値（bool）
- `is_`
- `has_`
- `can_`
- `should_`

```python
is_valid = True
has_error = False
```

---

## 4. 関数名の命名規約

### 動詞＋目的語が基本
```python
get_user()
create_order()
update_status()
delete_file()
```

### ❌ NG例
```python
user()
order()
process()
```

---

## 5. クラス名の命名規約

### 名詞 + 責務
```python
User
UserService
OrderController
PaymentRepository
```

### FastAPI / 業務系でよくある分け方
- `Service`：業務ロジック
- `Repository`：DBアクセス
- `Controller` / `Router`：API入口
- `Schema` / `DTO`：データ構造

---

## 6. 定数の命名規約

```python
MAX_LIMIT = 100
DEFAULT_TIMEOUT_SEC = 30
API_BASE_URL = "https://example.com"
```

- **大文字＋アンダースコア**
- クラス内でも同様

---

## 7. プライベート・内部用の命名

```python
_internal_value = 10

def _validate_input():
    pass
```

- `_` は **「外から使うな」意思表示**
- 強制ではない（Pythonらしさ）

---

## 8. モジュール・ファイル名

```text
user.py
user_service.py
order_repository.py
```

❌ NG
```text
UserService.py
user-service.py
```

---

## 9. よくあるアンチパターン ❌

| 悪い例 | なぜダメ |
|---|---|
| `data1`, `data2` | 意味不明 |
| `func()` | 役割が分からない |
| `check()` | 何を？ |
| 日本語ローマ字 | 検索性が悪い |

---

## 10. 実務向けおすすめ追加ルール（標準化用）

**チーム規約に入れると良い項目**
- 省略禁止リスト（`cnt`, `flg`, `tmp` など）
- bool 接頭辞統一（`is_`, `has_`）
- Service / Repository 命名統一
- API 関数は動詞必須

---

## 11. 公式参照（根拠）

- **PEP8 – Naming Conventions**
- **PEP257 – Docstring Conventions**

---

もし次に  
👉 **「Python + FastAPI 用 命名規約テンプレ（開発標準にそのまま貼れる版）」**  
👉 **「React / TypeScript と命名を揃えたクロス規約」**  

が欲しければ、そこまで作りますよ。

---

### [12:50] ユーザー
Python コーディング規約　ワークワイルとかの命名規約

---

### [12:51] アシスタント
了解しました。  
以下は **「Python + FastAPI 用 命名規約テンプレート」**です。  
👉 **そのまま「開発標準／実装規約」に貼り付け可能な完成版**として書いています。

---

# Python + FastAPI 命名規約  
（開発標準・実装規約テンプレート）

---

## 1. 目的

本規約は、Python + FastAPI を用いたバックエンド開発において、  
**可読性・保守性・レビュー効率を高めるため、命名ルールを統一する**ことを目的とする。

---

## 2. 基本方針

- **PEP8 を正式基準とする**
- 名前から **責務・役割・型が推測できること**
- チーム内で **省略・表記ゆれを禁止**する
- FastAPI の責務分離（Router / Service / Repository）を前提とする

---

## 3. 命名規約一覧（必須）

### 3.1 共通ルール

- 英語表記のみ（ローマ字・日本語禁止）
- `snake_case` を基本とする
- 省略語は禁止（例外は一般的な略語のみ）

**使用可の略語例**
- `id`
- `url`
- `api`
- `db`
- `json`

---

## 4. 変数の命名規約

### 4.1 形式

```
snake_case
```

### 4.2 命名ルール

- 名詞または名詞句
- データ内容が推測できる名称とする

```python
user_id: int
order_total_amount: Decimal
created_at: datetime
```

### 4.3 bool 型の命名

| 接頭辞 | 用途 |
|---|---|
| `is_` | 状態 |
| `has_` | 所有 |
| `can_` | 権限 |
| `should_` | 判断 |

```python
is_active = True
has_permission = False
can_edit = True
```

---

## 5. 関数の命名規約

### 5.1 形式

```
snake_case
```

### 5.2 命名ルール

- **動詞 + 目的語**
- 処理内容が明確に分かる名称とする

```python
get_user_by_id()
create_order()
update_user_status()
delete_expired_token()
```

❌ 禁止例
```python
process()
handle()
execute()
```

---

## 6. クラスの命名規約

### 6.1 形式

```
PascalCase
```

### 6.2 種別ごとの命名

| 種別 | 接尾辞 | 例 |
|---|---|---|
| エンティティ | なし | `User`, `Order` |
| Service | `Service` | `UserService` |
| Repository | `Repository` | `UserRepository` |
| Router | `Router` | `UserRouter` |
| Schema (Pydantic) | `Schema` / `Request` / `Response` | `UserCreateRequest` |
| 例外 | `Error` | `ValidationError` |

---

## 7. FastAPI 固有の命名規約

### 7.1 Router

```python
router = APIRouter(prefix="/users")
```

- router 変数名は **必ず `router`**
- エンドポイント関数は **HTTP 動詞 + 資源**

```python
@router.get("/{user_id}")
def get_user(user_id: int):
    ...
```

---

### 7.2 API エンドポイント関数

| HTTP | 命名例 |
|---|---|
| GET | `get_user` |
| POST | `create_user` |
| PUT | `update_user` |
| DELETE | `delete_user` |

---

## 8. Pydantic Schema の命名規約

### 8.1 形式

```
PascalCase
```

### 8.2 分類

```python
class UserCreateRequest(BaseModel):
    name: str
    email: str


class UserResponse(BaseModel):
    id: int
    name: str
```

---

## 9. ファイル・モジュール命名規約

### 9.1 ファイル名

```
snake_case.py
```

```text
user_router.py
user_service.py
user_repository.py
user_schema.py
```

### 9.2 ディレクトリ構成例

```text
app/
 ├─ routers/
 ├─ services/
 ├─ repositories/
 ├─ schemas/
 ├─ models/
```

---

## 10. 定数の命名規約

```python
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT_SEC = 30
```

- 大文字 + アンダースコア
- クラス内定数も同様

---

## 11. プライベート命名規約

```python
_internal_method()
_internal_value
```

- `_` プレフィックスを付与
- 外部からの利用は禁止

---

## 12. 禁止事項（必須）

- `tmp`, `cnt`, `flg` 等の省略
- 意味のない汎用名（`data`, `info`, `value`）
- ローマ字日本語
- クラスと関数での命名形式混在

---

## 13. チェックリスト（レビュー用）

- [ ] 命名規約に準拠しているか  
- [ ] 関数名が動詞になっているか  
- [ ] bool 型の接頭辞が統一されているか  
- [ ] Service / Repository が責務通り分離されているか  

---

## 14. 準拠規格

- PEP8
- PEP257
- FastAPI Best Practices

---

必要であれば次に  
👉 **「React / TypeScript 側と完全に対応させた命名規約」**  
👉 **「レビュー指摘テンプレ（NG例つき）」**  
👉 **「開発標準 Ver.X.Y に統合済み版」**  

まで一気に仕上げられます。  
どうします？

---

### [12:51] ユーザー
Python + FastAPI 用 命名規約テンプレ（開発標準にそのまま貼れる版）

